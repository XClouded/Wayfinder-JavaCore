/*******************************************************************************
 * Copyright (c) 1999-2010, Vodafone Group Services
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met:
 * 
 *     * Redistributions of source code must retain the above copyright 
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above 
 *       copyright notice, this list of conditions and the following 
 *       disclaimer in the documentation and/or other materials provided 
 *       with the distribution.
 *     * Neither the name of Vodafone Group Services nor the names of its 
 *       contributors may be used to endorse or promote products derived 
 *       from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
 * OF SUCH DAMAGE.
 ******************************************************************************/
package com.wayfinder.core.network.internal.xscoder;

final class XsDataCoder {

    /**
     * This is the shared key use by both server and client when 
     * encrypting / decrypting the data. If you plan to set up a server of
     * your own, it might be a good idea to generate a key of your own.
     * 
     * Otherwise others (who also had the brilliant idea of using this code)
     * could decrypt any intercepted data.
     */
    private static final short[] XOR_KEY = {
        0x4c, 0x87, 0x3f, 0x4f, 0xea, 0xa8, 0xa4, 0xb7, 0xb4, 0x13, 0xba, 0x4b,
        0xea, 0xa8, 0xa4, 0xb7, 0xb4, 0x13, 0xba, 0x4b, 0x54, 0x58, 0xc7, 0x01,
        0xb4, 0x13, 0xba, 0x4b, 0x54, 0x58, 0xc7, 0x01, 0xb5, 0xc9, 0x89, 0x03,
        0x54, 0x58, 0xc7, 0x01, 0xb5, 0xc9, 0x89, 0x03, 0x77, 0x78, 0xe4, 0x46,
        0xb5, 0xc9, 0x89, 0x03, 0x77, 0x78, 0xe4, 0x46, 0xb4, 0xe1, 0x91, 0x25,
        0x77, 0x78, 0xe4, 0x46, 0xb4, 0xe1, 0x91, 0x25, 0x96, 0x63, 0xf8, 0xe1,
        0xb4, 0xe1, 0x91, 0x25, 0x96, 0x63, 0xf8, 0xe1, 0xea, 0x37, 0x2f, 0xd4,
        0x96, 0x63, 0xf8, 0xe1, 0xea, 0x37, 0x2f, 0xd4, 0xde, 0xd3, 0x8a, 0x92,
        0xea, 0x37, 0x2f, 0xd4, 0xde, 0xd3, 0x8a, 0x92, 0xe6, 0x43, 0xdc, 0x39,
        0xde, 0xd3, 0x8a, 0x92, 0xe6, 0x43, 0xdc, 0x39, 0x9a, 0xa2, 0x3a, 0x4e,
        0xe6, 0x43, 0xdc, 0x39, 0x9a, 0xa2, 0x3a, 0x4e, 0x6b, 0xc3, 0x51, 0xe2,
        0x9a, 0xa2, 0x3a, 0x4e, 0x6b, 0xc3, 0x51, 0xe2, 0x3a, 0x34, 0x27, 0xee,
        0x6b, 0xc3, 0x51, 0xe2, 0x3a, 0x34, 0x27, 0xee, 0x15, 0xb8, 0x12, 0xaa,
        0x3a, 0x34, 0x27, 0xee, 0x15, 0xb8, 0x12, 0xaa, 0x1b, 0x0a, 0x8a, 0x04,
        0x15, 0xb8, 0x12, 0xaa, 0x1b, 0x0a, 0x8a, 0x04, 0x40, 0xb9, 0xd7, 0x1e,
        0x1b, 0x0a, 0x8a, 0x04, 0x40, 0xb9, 0xd7, 0x1e, 0x8c, 0x60, 0xaf, 0x71,
        0x40, 0xb9, 0xd7, 0x1e, 0x8c, 0x60, 0xaf, 0x71, 0xa2, 0x8a, 0xaa, 0x3c,
        0x8c, 0x60, 0xaf, 0x71, 0xa2, 0x8a, 0xaa, 0x3c, 0x2c, 0xe3, 0x8a, 0x96,
        0xa2, 0x8a, 0xaa, 0x3c, 0x2c, 0xe3, 0x8a, 0x96, 0xa5, 0xdb, 0x77, 0xdf,
        0x2c, 0xe3, 0x8a, 0x96, 0xa5, 0xdb, 0x77, 0xdf, 0x0e, 0x9e, 0xcc, 0x22,
        0xa5, 0xdb, 0x77, 0xdf, 0x0e, 0x9e, 0xcc, 0x22, 0x55, 0xde, 0xcc, 0x6f,
        0x0e, 0x9e, 0xcc, 0x22
    };

    private static final int XOR_KEY_LEN = 256;

    /**
     * @return next keypos
     */
    private static int code(byte[] buf, int offset, int len, int keyPos) {
        int kp = keyPos;
        for(int i=offset;
            i < (offset + len);
            i++, kp  = (kp + 1) % XOR_KEY_LEN) {
            buf[i] = (byte) (buf[i] ^ XOR_KEY[kp]);
        }

        return kp;
    }


    // ----------------------------------------------------------------------
    // instance interface - used by streams
    private int m_keyPos;
    
    XsDataCoder() {}

    /**
     * process the next byte of input.
     */
    byte processNextByte(byte b) {
        b = (byte) (b ^ XOR_KEY[m_keyPos]);
        m_keyPos = (m_keyPos + 1) % XOR_KEY_LEN;

        return b;
    }

    /**
     * like processNextByte, but works on blocks
     */
    void processNextBlock(byte[] buf, int offset, int len) {
        m_keyPos = XsDataCoder.code(buf, offset, len, m_keyPos);
    }
}
